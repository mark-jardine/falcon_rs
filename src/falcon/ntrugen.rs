/*
    Implementation of the Falcon Digital Signature Scheme.
    Copyright (C) 2024 Mark Jardine

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    Portions of this software are adapted from work by Thomas Prest, 2018,
    licensed under the MIT License. See the LICENSE_MIT file in this distribution
    for the full license text.
*/

use super::{
    fft::FftError,
    finite_field_element::Q,
    polynomial::{karamul, Polynomial},
};
use num_bigint::BigInt;
use num_complex::Complex64;

#[derive(Debug)]
pub enum NtruError {
    DivisionError,
    XgcdError,
    ReductionError,
    Other(String), // For miscellaneous errors
}

impl std::fmt::Display for NtruError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl std::error::Error for NtruError {}

/*
   Compute the bitsize of an element of Z (not counting the sign).
   The bitsize is rounded to the next multiple of 8.
   This makes the function slightly imprecise, but faster to compute.
*/
pub fn bitsize(a: BigInt) -> u64 {
    // Will be a 61 1's, and the final three bits as 0's
    let bitmask = u64::MAX ^ 0b0111;
    // Add 7 to ensure rounding up to next multiple of 8
    // Then round down to a multiple of 8
    (a.bits() + 0b0111) & bitmask
    // E.g.
    // if a = 10
    // 10 + 7 & bitmask
    // 0000_1010 + 0000_0111 & (1111_1111..._1000)
    // = 0001_0001 [=17] & ..._1111_1000
    // = 0001_0000 [=16]
}

/*
    Compute the extended GCD of two integers b and n.
    Return d, u, v such that d = u * b + v * n, and d is the GCD of b, n.

    Params:
        - b: i64
        - n: i64

    Returns:
        - a tuple of three i64 values (d, u, v) such that d = u * b + v * n
*/
pub fn xgcd(mut b: BigInt, mut n: BigInt) -> (BigInt, BigInt, BigInt) {
    let (mut x0, mut x1, mut y0, mut y1) = (
        BigInt::from(1),
        BigInt::from(0),
        BigInt::from(0),
        BigInt::from(1),
    );

    while n != BigInt::from(0) {
        let q = b.clone() / n.clone();
        let n_tmp = n.clone();
        n = b % n;
        b = n_tmp;

        let x1_tmp = x1.clone();
        x1 = x0 - q.clone() * x1;
        x0 = x1_tmp;

        let y1_tmp = y1.clone();
        y1 = y0 - q * y1;
        y0 = y1_tmp;
    }

    (b, x0, y0)
}

/*
    Solve the NTRU equation for f and g.
    Corresponds to NTRUSolve in Falcon's documentation.

    Params:
        - f: a Polynomial<BigInt>
        - g: a Polynomial<BigInt>

    Returns:
        - (F, G), a tuple of Polynomial<BigInt> or an Error
*/
fn ntru_solve(
    f: Polynomial<BigInt>,
    g: Polynomial<BigInt>,
) -> Result<(Polynomial<BigInt>, Polynomial<BigInt>), NtruError> {
    let len = f.coefficients.len();
    dbg!(len);
    if len == 1 {
        let f0 = f.coefficients[0].clone();
        let g0 = g.coefficients[0].clone();
        let (d, u, v) = xgcd(f0, g0);
        dbg!((d.clone(), u.clone(), v.clone()));
        if d != BigInt::from(1) && d != BigInt::from(-1) {
            eprintln!("d == {d}");
            Err(NtruError::XgcdError)
        } else {
            Ok((
                Polynomial::new(vec![(v * -BigInt::from(Q))]),
                Polynomial::new(vec![BigInt::from(Q) * u]),
            ))
        }
    } else {
        let fp = Polynomial::field_norm(&f);
        let gp = Polynomial::field_norm(&g);
        let (capf_p, capg_p) = match ntru_solve(fp, gp) {
            Ok(res) => res,
            Err(e) => return Err(NtruError::from(e)),
        };
        let mut capf = Polynomial::new(karamul(
            &Polynomial::lift(&capf_p).coefficients,
            &Polynomial::galois_conjugate(&g).coefficients,
        ));
        let mut capg = Polynomial::new(karamul(
            &Polynomial::lift(&capg_p).coefficients,
            &Polynomial::galois_conjugate(&f).coefficients,
        ));
        let _ = Polynomial::reduce(f, g, &mut capf, &mut capg);
        Ok((capf, capg))
    }
}

/*
    Compute the squared Gram-Schmidt norm of the NTRU matrix generated by f, g.
    This matrix is [[g, - f], [G, - F]].
    This algorithm is equivalent to line 9 of algorithm 5 (NTRUGen).
*/
fn gs_norm(f: &Polynomial<f64>, g: &Polynomial<f64>) -> Result<f64, FftError> {
    let sqnorm_fg = Polynomial::sqnorm(&f) + Polynomial::sqnorm(&g);
    let f_complex = f.map_to_complex();
    let g_complex = g.map_to_complex();

    let ffgg = (f.to_owned() * Polynomial::adjoint(&f_complex)?)
        + (g.to_owned() * Polynomial::adjoint(&g_complex)?);
    let capf_t = Polynomial::adjoint(&g_complex)? / ffgg.clone();
    let capg_t = Polynomial::adjoint(&f_complex)? / ffgg;
    let q_sq = Q as f64 * Q as f64;
    let sqnorm_cap_fg = q_sq * (Polynomial::sqnorm(&capf_t) + Polynomial::sqnorm(&capg_t));

    Ok(f64::max(sqnorm_fg, sqnorm_cap_fg))
}

#[cfg(test)]
mod test {
    use std::str::FromStr;

    use super::*;
    use num_bigint::BigInt;

    #[test]
    fn test_ntru_solve_custom_case() {
        let f_values = vec![
            -3, 3, 6, -13, 19, -10, 2, 0, 4, 18, -1, 3, 11, 12, 8, 9, 13, -7, 14, 4, 14, 5, 1, -1,
            5, 10, -14, -20, 7, -1, -5, -20, 0, 9, 13, 18, 2, 4, 18, 4, -8, 10, -14, -19, 5, -10,
            7, -8, 1, 5, 23, -15, 7, -1, -8, -1, 17, 8, -17, -15, 3, 17, 6, 9,
        ];
        let g_values = vec![
            2, 5, -26, 1, -1, 2, 11, 12, -3, -13, 2, -21, 13, -12, -2, 17, 21, -5, -1, 8, -13, 13,
            14, 1, -8, 3, -7, -14, -6, 2, 0, 4, -10, -13, -20, -10, -8, -3, -16, -14, 8, -1, 11,
            -3, 17, 19, 16, 12, 0, 24, -21, 6, 2, -17, -5, -8, 1, 2, 9, -19, 8, -8, 8, -5,
        ];

        // Convert vectors to Polynomials of BigInts
        let f = Polynomial::new(f_values.into_iter().map(|x| BigInt::from(x)).collect());
        let g = Polynomial::new(g_values.into_iter().map(|x| BigInt::from(x)).collect());

        //let expected_d = BigInt::from(1);
        let expected_u = BigInt::from_str("-1042988606416744386067344268752767846478900590042196547328557948003748662386381960937061464496930231771159302123335535").unwrap();
        let expected_v = BigInt::from_str("1505450870159096382669079467671730672781040183289270473933643873183017670046652058185493479254607661110758227868127").unwrap();

        let expected_capf_values = vec![
            -4, 6, 20, -47, 12, -43, -11, 5, -12, -18, -1, -2, -10, -14, -65, 60, 3, 0, -19, -21,
            4, -12, 35, -26, -41, 21, -15, 37, 19, 12, -17, 38, -17, 10, -59, 53, -51, -20, -52,
            18, -52, 14, 23, 5, -19, 17, -9, 53, 68, 29, -1, -23, 55, 28, 4, 5, 24, 17, -11, 27,
            -18, 0, -38, 6,
        ];
        let expected_capg_values = vec![
            -5, -1, 9, 32, 17, 31, 67, 25, 7, 6, 38, -40, 16, -9, 20, -44, -12, -53, 7, -19, -33,
            -3, 16, 27, -9, 2, -26, 33, -9, 16, -21, -55, 49, 15, 21, 1, 34, 6, 41, -11, -18, -6,
            -15, 5, -15, -23, -74, -1, -63, 18, -58, 1, -27, 26, 8, 15, 34, -1, 39, 46, 16, -36, 7,
            -23,
        ];
        let expected_capf = Polynomial::new(
            expected_capf_values
                .into_iter()
                .map(|x| BigInt::from(x))
                .collect(),
        );
        let expected_capg = Polynomial::new(
            expected_capg_values
                .into_iter()
                .map(|x| BigInt::from(x))
                .collect(),
        );

        // Run the test
        match ntru_solve(f, g) {
            Ok((capf, capg)) => {
                assert_eq!(
                    capf.coefficients, expected_capf.coefficients,
                    "F polynomial does not match expected"
                );
                assert_eq!(
                    capg.coefficients, expected_capg.coefficients,
                    "G polynomial does not match expected"
                );
            }
            Err(e) => panic!("Error encountered in ntru_solve: {e}"),
        }
    }
}
